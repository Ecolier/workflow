import { WorkflowGraph, WorkflowNode } from "./schemas/workflow-schema.ts";

interface WorkflowNodeExecutionResult {
  output: string;
  nextNodeId?: string;
}

interface WorkflowExecutionContext {
  input: string;
  lastOutput: string;
  currentNodeId: string;
  executionPath: string[];
}

export type HandlePromptFn = (prompt: string) => Promise<string>;

/**
 * Populates the prompt template with values from the execution context.
 * @param prompt - The prompt template with placeholders.
 * @param context - The workflow execution context containing input and last output.
 * @returns The populated prompt with replaced values.
 */
const populatePrompt = (prompt: string, context: WorkflowExecutionContext) =>
  prompt
    .replace(/\{\{input\}\}/g, context.input)
    .replace(/\{\{lastOutput\}\}/g, context.lastOutput);

/**
 * Determines the next node in the workflow based on the current node's routing and the output.
 * @param node - The current workflow node.
 * @param output - The output generated by the current node.
 * @returns The ID of the next node, or undefined if there is no next node.
 */
const determineNextNode = (
  { routing }: WorkflowNode,
  output: string
): string | undefined => {
  switch (routing.type) {
    case "conditional": {
      // Clean output for comparison (lowercase, trim)
      const cleanOutput = output.toLowerCase().trim();

      // Find matching condition
      for (const [condition, targetNode] of Object.entries(routing.condition)) {
        if (cleanOutput.includes(condition.toLowerCase())) {
          return targetNode;
        }
      }
      return undefined;
    }
    case "direct":
      return routing.next;
    case "terminal":
      return undefined;
    default:
      throw new Error(`Unknown routing type`);
  }
};

/* Executes a workflow by processing each node in sequence.
 * @param workflow - The workflow graph containing nodes and their connections.
 * @param input - The initial input for the workflow.
 * @param handlePrompt - A function to process each node's prompt and return the output.
 * @returns The final output after processing all nodes.
 */
export default async function executeWorkflow(
  workflow: WorkflowGraph,
  input: string,
  handlePrompt: HandlePromptFn
): Promise<string> {
  /* Executes a single node in the workflow, populating its prompt and determining the next node.
   * @param context - The current execution context containing input, last output, and current node ID.
   * @returns The output of the node and the ID of the next node to execute.
   */
  const executeNode = async (
    context: WorkflowExecutionContext
  ): Promise<WorkflowNodeExecutionResult> => {
    const node = workflow.nodes.get(context.currentNodeId);
    if (!node) {
      throw new Error(`Node "${context.currentNodeId}" not found`);
    }
    const populatedPrompt = populatePrompt(node.prompt, context);
    const output = await handlePrompt(populatedPrompt);
    const nextNodeId = determineNextNode(node, output);
    return { output, nextNodeId };
  };

  const context: WorkflowExecutionContext = {
    input,
    lastOutput: input,
    currentNodeId: workflow.startNode,
    executionPath: [],
  };

  while (context.currentNodeId) {
    const result = await executeNode(context);
    context.lastOutput = result.output;
    context.executionPath.push(context.currentNodeId);
    context.currentNodeId = result.nextNodeId || "";

    // Prevent infinite loops
    if (context.executionPath.length > 50) {
      throw new Error("Workflow execution exceeded maximum depth");
    }
  }
  return context.lastOutput;
}
